42Seoul 본과정 진행상황

0서클 
	Libft : 125점 / 보너스 O
	-> 기본적인 라이브러리를 생성한 것으로 윗서클 과제에서도 사용이 됨
	-> Makefile을 통해 make / make bonus 입력을 통해서 아카이브를 생성 후에 이를 사용해서 다른 곳에서도 사용가능
	-> 자료구조 중 하나인 Linked List(연결리스트)를 보너스문제에서 구현

1서클 
	Printf : 100점 / 보너스 X
	-> printf를 구현하는 과제로, 처음으로 등장하는 가변인자 개념을 통해서 진행하는 과제
	-> Conversion의 종류인 cspdiuxX를 다뤘고, 보너스는 진행하지 않음
	-> 보너스의 경우, 다양한 플래그들이 주어지는데 이를 통해서 원본 printf와 동일하게 동작하게 만드는 것인데
	-> 고려해야하는 경우가 너무 많아서 패스
	
	Get_next_line : 125점 / 보너스 O
	-> fd를 통해서 입력값을 받아서 "\n", 즉 개행문자까지 한 줄씩 잘라서 반환해주는 함수를 구현하는것
	-> 이도 동일하게 뒤의 과제에서 유용하게 사용
	-> Norm의 규정에 맞추는게 어려웠었던 과제로, fd에 대해서 짚고 넘어갈 수 있는 문제
	-> 보너스의 경우, fd가 여러개 들어왔을 때, 이전의 fd를 잃어버리지 않고 한번에 담아두는 것으로
	-> 2차원 배열을 통해서 해결을 함 / 연결리스트로도 해결이 가능하다고 함
	
	Born2beroot : 100점 / 보너스 X
	-> 데비안을 설치해서 기본적인 OS에 관해서 다루는 과제
	-> 가상머신(버츄얼박스)를 사용해서 OS를 설치하는 것
	-> 방화벽, SSH, 시스템의 사용상태 등등 기본적인 시스템을 배움
	-> 보너스의 경우, 웹서버 구축(마리아 DB사용), 파티션 재구축을 해야하는데, 할 줄 몰라서 진행하지 않음

2서클
	Push_swap : 125점 / 보너스 O
	-> 2서클에서 가장 난이도가 높다는 과제로 정렬되지 않은 수열을 받았을 때, 이를 정렬하는데
	-> 가장 효율적으로 정렬해서 명령어의 개수가 적게 나오도록 만드는 과제
	-> 총 5가지의 방법으로 가능하다고 알려져있음.
	-> 1. 퀵정렬 2. 병합정렬 3. 모래시계 정렬 4. 그리디 알고리즘 5. DP
	-> 이중에서 모래시계 정렬을 사용해서 해결했으며, 모래시계 알고리즘의 경우 이 문제만을 위한 풀이법이라고 봐도 무방함
	-> 보너스의 경우, 멘데토리를 진행했으면 바로 해결가능하며, 정렬이 정확하게 되었는지 판단하는 체커를 만드는 과제
	-> 약간의 예외처리만 조심하면 문제없음
	-> 개인적으로 처음에 ARGV를 처리하는 부분이 까다로웠고, 정렬에서 최적화를 진행하는 것도 생각을 해야하는 과제
